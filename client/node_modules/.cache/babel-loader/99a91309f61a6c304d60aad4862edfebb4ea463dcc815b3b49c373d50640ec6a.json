{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from '../utilities/globals/index.js';\nimport { ApolloLink, execute } from '../link/core/index.js';\nimport { version } from '../version.js';\nimport { HttpLink } from '../link/http/index.js';\nimport { QueryManager } from './QueryManager.js';\nimport { LocalState } from './LocalState.js';\nvar hasSuggestedDevtools = false;\nimport { mergeOptions } from \"../utilities/index.js\";\nexport { mergeOptions };\nvar ApolloClient = function () {\n  function ApolloClient(options) {\n    var _this = this;\n    this.resetStoreCallbacks = [];\n    this.clearStoreCallbacks = [];\n    if (!options.cache) {\n      throw newInvariantError(13);\n    }\n    var uri = options.uri,\n      credentials = options.credentials,\n      headers = options.headers,\n      cache = options.cache,\n      documentTransform = options.documentTransform,\n      _a = options.ssrMode,\n      ssrMode = _a === void 0 ? false : _a,\n      _b = options.ssrForceFetchDelay,\n      ssrForceFetchDelay = _b === void 0 ? 0 : _b,\n      _c = options.connectToDevTools,\n      connectToDevTools = _c === void 0 ? typeof window === 'object' && !window.__APOLLO_CLIENT__ && globalThis.__DEV__ !== false : _c,\n      _d = options.queryDeduplication,\n      queryDeduplication = _d === void 0 ? true : _d,\n      defaultOptions = options.defaultOptions,\n      _e = options.assumeImmutableResults,\n      assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e,\n      resolvers = options.resolvers,\n      typeDefs = options.typeDefs,\n      fragmentMatcher = options.fragmentMatcher,\n      clientAwarenessName = options.name,\n      clientAwarenessVersion = options.version;\n    var link = options.link;\n    if (!link) {\n      link = uri ? new HttpLink({\n        uri: uri,\n        credentials: credentials,\n        headers: headers\n      }) : ApolloLink.empty();\n    }\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    if (ssrForceFetchDelay) {\n      setTimeout(function () {\n        return _this.disableNetworkFetches = false;\n      }, ssrForceFetchDelay);\n    }\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n    if (connectToDevTools && typeof window === 'object') {\n      window.__APOLLO_CLIENT__ = this;\n    }\n    if (!hasSuggestedDevtools && connectToDevTools && globalThis.__DEV__ !== false) {\n      hasSuggestedDevtools = true;\n      if (typeof window !== 'undefined' && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n        var nav = window.navigator;\n        var ua = nav && nav.userAgent;\n        var url = void 0;\n        if (typeof ua === \"string\") {\n          if (ua.indexOf(\"Chrome/\") > -1) {\n            url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n          } else if (ua.indexOf(\"Firefox/\") > -1) {\n            url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n          }\n        }\n        if (url) {\n          globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: %s\", url);\n        }\n      }\n    }\n    this.version = version;\n    this.localState = new LocalState({\n      cache: cache,\n      client: this,\n      resolvers: resolvers,\n      fragmentMatcher: fragmentMatcher\n    });\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      documentTransform: documentTransform,\n      queryDeduplication: queryDeduplication,\n      ssrMode: ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName,\n        version: clientAwarenessVersion\n      },\n      localState: this.localState,\n      assumeImmutableResults: assumeImmutableResults,\n      onBroadcast: connectToDevTools ? function () {\n        if (_this.devToolsHookCb) {\n          _this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: _this.queryManager.getQueryStore(),\n              mutations: _this.queryManager.mutationStore || {}\n            },\n            dataWithOptimisticResults: _this.cache.extract(true)\n          });\n        }\n      } : void 0\n    });\n  }\n  Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n    get: function get() {\n      return this.queryManager.documentTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ApolloClient.prototype.stop = function () {\n    this.queryManager.stop();\n  };\n  ApolloClient.prototype.watchQuery = function (options) {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n    if (this.disableNetworkFetches && (options.fetchPolicy === 'network-only' || options.fetchPolicy === 'cache-and-network')) {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: 'cache-first'\n      });\n    }\n    return this.queryManager.watchQuery(options);\n  };\n  ApolloClient.prototype.query = function (options) {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n    invariant(options.fetchPolicy !== 'cache-and-network', 14);\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: 'cache-first'\n      });\n    }\n    return this.queryManager.query(options);\n  };\n  ApolloClient.prototype.mutate = function (options) {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate(options);\n  };\n  ApolloClient.prototype.subscribe = function (options) {\n    return this.queryManager.startGraphQLSubscription(options);\n  };\n  ApolloClient.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readQuery(options, optimistic);\n  };\n  ApolloClient.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readFragment(options, optimistic);\n  };\n  ApolloClient.prototype.writeQuery = function (options) {\n    var ref = this.cache.writeQuery(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  ApolloClient.prototype.writeFragment = function (options) {\n    var ref = this.cache.writeFragment(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n    this.devToolsHookCb = cb;\n  };\n  ApolloClient.prototype.__requestRaw = function (payload) {\n    return execute(this.link, payload);\n  };\n  ApolloClient.prototype.resetStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: false\n      });\n    }).then(function () {\n      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n  ApolloClient.prototype.clearStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: true\n      });\n    }).then(function () {\n      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    });\n  };\n  ApolloClient.prototype.onResetStore = function (cb) {\n    var _this = this;\n    this.resetStoreCallbacks.push(cb);\n    return function () {\n      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  ApolloClient.prototype.onClearStore = function (cb) {\n    var _this = this;\n    this.clearStoreCallbacks.push(cb);\n    return function () {\n      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  };\n  ApolloClient.prototype.refetchQueries = function (options) {\n    var map = this.queryManager.refetchQueries(options);\n    var queries = [];\n    var results = [];\n    map.forEach(function (result, obsQuery) {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n    var result = Promise.all(results);\n    result.queries = queries;\n    result.results = results;\n    result.catch(function (error) {\n      globalThis.__DEV__ !== false && invariant.debug(15, error);\n    });\n    return result;\n  };\n  ApolloClient.prototype.getObservableQueries = function (include) {\n    if (include === void 0) {\n      include = \"active\";\n    }\n    return this.queryManager.getObservableQueries(include);\n  };\n  ApolloClient.prototype.extract = function (optimistic) {\n    return this.cache.extract(optimistic);\n  };\n  ApolloClient.prototype.restore = function (serializedState) {\n    return this.cache.restore(serializedState);\n  };\n  ApolloClient.prototype.addResolvers = function (resolvers) {\n    this.localState.addResolvers(resolvers);\n  };\n  ApolloClient.prototype.setResolvers = function (resolvers) {\n    this.localState.setResolvers(resolvers);\n  };\n  ApolloClient.prototype.getResolvers = function () {\n    return this.localState.getResolvers();\n  };\n  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  };\n  ApolloClient.prototype.setLink = function (newLink) {\n    this.link = this.queryManager.link = newLink;\n  };\n  return ApolloClient;\n}();\nexport { ApolloClient };","map":{"version":3,"names":["invariant","newInvariantError","ApolloLink","execute","version","HttpLink","QueryManager","LocalState","hasSuggestedDevtools","mergeOptions","ApolloClient","options","_this","resetStoreCallbacks","clearStoreCallbacks","cache","uri","credentials","headers","documentTransform","_a","ssrMode","_b","ssrForceFetchDelay","_c","connectToDevTools","window","__APOLLO_CLIENT__","globalThis","__DEV__","_d","queryDeduplication","defaultOptions","_e","assumeImmutableResults","resolvers","typeDefs","fragmentMatcher","clientAwarenessName","name","clientAwarenessVersion","link","empty","disableNetworkFetches","Object","create","setTimeout","watchQuery","bind","query","mutate","resetStore","reFetchObservableQueries","document","top","self","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","nav","navigator","ua","userAgent","url","indexOf","log","localState","client","queryManager","clientAwareness","onBroadcast","devToolsHookCb","action","state","queries","getQueryStore","mutations","mutationStore","extract","defineProperty","prototype","get","configurable","stop","fetchPolicy","__assign","subscribe","startGraphQLSubscription","readQuery","optimistic","readFragment","writeQuery","ref","broadcast","broadcastQueries","writeFragment","__actionHookForDevTools","cb","__requestRaw","payload","Promise","resolve","then","clearStore","discardWatches","all","map","fn","onResetStore","push","filter","c","onClearStore","includeStandby","refetchQueries","results","forEach","result","obsQuery","catch","error","debug","getObservableQueries","include","restore","serializedState","addResolvers","setResolvers","getResolvers","setLocalStateFragmentMatcher","setFragmentMatcher","setLink","newLink"],"sources":["/Users/freddydordoni/bootcamp/Project-3-Portfolio-Tracker/client/node_modules/@apollo/src/core/ApolloClient.ts"],"sourcesContent":["import { invariant, newInvariantError } from '../utilities/globals/index.js';\n\nimport type { ExecutionResult, DocumentNode } from 'graphql';\n\nimport type { FetchResult, GraphQLRequest} from '../link/core/index.js';\nimport { ApolloLink, execute } from '../link/core/index.js';\nimport type { ApolloCache, DataProxy, Reference } from '../cache/index.js';\nimport type { DocumentTransform, Observable } from '../utilities/index.js';\nimport { version } from '../version.js';\nimport type { UriFunction } from '../link/http/index.js';\nimport { HttpLink } from '../link/http/index.js';\n\nimport { QueryManager } from './QueryManager.js';\nimport type { ObservableQuery } from './ObservableQuery.js';\n\nimport type {\n  ApolloQueryResult,\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n} from './types.js';\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from './watchQueryOptions.js';\n\nimport type {\n  FragmentMatcher} from './LocalState.js';\nimport {\n  LocalState\n} from './LocalState.js';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  uri?: string | UriFunction;\n  credentials?: string;\n  headers?: Record<string, string>;\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n  documentTransform?: DocumentTransform\n};\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nexport { mergeOptions }\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param uri The GraphQL endpoint that Apollo Client will connect to. If\n   *            `link` is configured, this option is ignored.\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n        \"in the options object. \\n\" +\n        \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools =\n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        typeof window === 'object' &&\n        !(window as any).__APOLLO_CLIENT__ &&\n        __DEV__,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link = uri\n        ? new HttpLink({ uri, credentials, headers })\n        : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    if (connectToDevTools && typeof window === 'object') {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && connectToDevTools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self &&\n        !(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__\n      ) {\n        const nav = window.navigator;\n        const ua = nav && nav.userAgent;\n        let url: string | undefined;\n        if (typeof ua === \"string\") {\n          if (ua.indexOf(\"Chrome/\") > -1) {\n            url = \"https://chrome.google.com/webstore/detail/\" +\n              \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n          } else if (ua.indexOf(\"Firefox/\") > -1) {\n            url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n          }\n        }\n        if (url) {\n          invariant.log(\n            \"Download the Apollo DevTools for a better development \" +\n              \"experience: %s\", url\n          );\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: connectToDevTools ? () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.getQueryStore(),\n              mutations: this.queryManager.mutationStore || {},\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      } : void 0,\n    });\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables extends OperationVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVariables, T>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>\n  >(\n    options: MutationOptions<TData, TVariables, TContext>,\n  ): Promise<FetchResult<TData>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables extends OperationVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables, T>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore({\n        discardWatches: false,\n      }))\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore({\n        discardWatches: true,\n      }))\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<ApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>,\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(options);\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch(error => {\n      invariant.debug(`In client.refetchQueries, Promise.all promise rejected with error %o`, error);\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\",\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}